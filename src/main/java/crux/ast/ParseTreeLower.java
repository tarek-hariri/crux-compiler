package crux.ast;

import crux.ast.*;
import crux.ast.OpExpr.Operation;
import crux.ir.Variable;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows
 * the visitor pattern
 * where decls will be by DeclVisitor Class Stmts will be resolved by
 * StmtVisitor Class Exprs will
 * be resolved by ExprVisitor Class
 */

public final class ParseTreeLower {
  private final DeclVisitor declVisitor = new DeclVisitor();
  private final StmtVisitor stmtVisitor = new StmtVisitor();
  private final ExprVisitor exprVisitor = new ExprVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }

  public DeclarationList lower(CruxParser.ProgramContext program) {
    List<Declaration> declarations = new ArrayList<>();
    for (CruxParser.DeclContext declContext : program.declList().decl()) {
      Declaration decl = declVisitor.visit(declContext);
      if (decl != null) {
        declarations.add(decl);
      }
    }
    return new DeclarationList(makePosition(program), declarations);
  }

  /**
   * Lower stmt list by lower individual stmt into AST.
   *
   * @return a {@link StatementList} AST object.
   */

  private StatementList lower(CruxParser.StmtListContext stmtList) {
    List<Statement> statements = new ArrayList<>();
    for (CruxParser.StmtContext stmtContext : stmtList.stmt()) {
      Statement stmt = stmtVisitor.visit(stmtContext);
      if (stmt != null) {
        statements.add(stmt);
      }
    }
    return new StatementList(makePosition(stmtList), statements);
  }

  /**
   * Similar to {@link #lower(CruxParser.StmtListContext)}, but handles symbol
   * table as well.
   *
   * @return a {@link StatementList} AST object.
   */
  private StatementList lower(CruxParser.StmtBlockContext stmtBlock) {
    symTab.enter();

    List<Statement> statements = new ArrayList<>();
    if (stmtBlock.stmtList() != null) {
      for (CruxParser.StmtContext stmtContext : stmtBlock.stmtList().stmt()) {
        Statement stmt = stmtVisitor.visit(stmtContext);
        if (stmt != null) {
          statements.add(stmt);
        }
      }
    }

    symTab.exit();
    return new StatementList(makePosition(stmtBlock), statements);
  }

  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}
     *
     * @return an AST {@link VariableDeclaration}
     */

    public Type StringToType(String str) {
      if (str.equals("void")) {
        return new VoidType();
      } else if (str.equals("int")) {
        return new IntType();
      } else if (str.equals("bool")) {
        return new BoolType();
      }
      // Should never get here, this is for catching bugs
      return null;
    }

    @Override
    public VariableDeclaration visitVarDecl(CruxParser.VarDeclContext ctx) {
      String name = ctx.Identifier().getText();
      Type type = StringToType(ctx.type().getText());
      Position position = makePosition(ctx);

      Symbol symbol = symTab.add(position, name, type);
      if (symbol == null) {
        return null;
      }

      return new VariableDeclaration(position, symbol);
    }

    /**
     * Visit a parse tree array decl and creates an AST {@link ArrayDeclaration}
     *
     * @return an AST {@link ArrayDeclaration}
     */

    @Override
    public Declaration visitArrayDecl(CruxParser.ArrayDeclContext ctx) {
      String name = ctx.Identifier().getText();
      Type baseType = StringToType(ctx.type().getText());
      int length = Integer.parseInt(ctx.Integer().getText());
      Position position = makePosition(ctx);

      ArrayType type = new ArrayType(length, baseType);

      Symbol symbol = symTab.add(position, name, type);
      if (symbol == null) {
        return null;
      }

      return new ArrayDeclaration(position, symbol);
    }

    /**
     * Visit a parse tree function definition and create an AST
     * {@link FunctionDefinition}
     *
     * @return an AST {@link FunctionDefinition}
     */

    @Override
    public Declaration visitFunctionDefn(CruxParser.FunctionDefnContext ctx) {
      String name = ctx.Identifier().getText();
      List<Symbol> parameters = new ArrayList<>();
      Type returnType = StringToType(ctx.type().getText());
      Position position = makePosition(ctx);

      symTab.enter();

      for (CruxParser.ParamContext paramCtx : ctx.paramList().param()) {
        String paramName = paramCtx.Identifier().getText();
        Type paramType = StringToType(paramCtx.type().getText());
        Symbol paramSymbol = symTab.add(position, paramName, paramType);
        if (paramSymbol == null) {
          System.err.println("Error: Parameter '" + paramName + "' could not be added to symbol table.");
          continue;
        }
        parameters.add(paramSymbol);
      }

      FuncType functionType = new FuncType(new TypeList(parameters.stream().map(Symbol::getType).collect(Collectors.toList())), returnType);

      Symbol functionSymbol = symTab.add(position, name, functionType);
      if (functionSymbol == null) {
        System.err.println("Error: Function '" + name + "' could not be added to symbol table.");
        return null;
      }

      StatementList body = lower(ctx.stmtBlock());

      return new FunctionDefinition(position, functionSymbol, parameters, body);
    }
  }

  /**
   * A parse tree visitor to create AST nodes derived from {@link Statement}
   */

  private final class StmtVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}.
     * Since
     * {@link VariableDeclaration} is both {@link Declaration} and
     * {@link Statement}, we simply
     * delegate this to
     * {@link DeclVisitor#visitArrayDecl(CruxParser.ArrayDeclContext)} which we
     * implement earlier.
     *
     * @return an AST {@link VariableDeclaration}
     */

    @Override
    public Statement visitVarDecl(CruxParser.VarDeclContext ctx) {
      return (Statement) declVisitor.visitVarDecl(ctx);
    }

    /**
     * Visit a parse tree assignment stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */

    @Override
    public Statement visitAssignStmt(CruxParser.AssignStmtContext ctx) {
      String identifier = ctx.designator().Identifier().getText();
      Symbol symbol = symTab.lookup(makePosition(ctx), identifier);

      if (symbol == null || symbol.getType() == null) {
        System.err.println("Error: Undefined symbol '" + identifier + "'.");
        return null;
      }

      Expression expr = exprVisitor.visit(ctx.expr0());
      Position position = makePosition(ctx);

      if (ctx.designator().expr0() != null && !ctx.designator().expr0().isEmpty()) {
        Expression index = exprVisitor.visit(ctx.designator().expr0(0));
        if (index == null) {
          System.err.println("Error: Invalid index expression for array access.");
          return null;
        }
        ArrayAccess arrayAccess = new ArrayAccess(position, symbol, index);
        return new Assignment(position, arrayAccess, expr);
      } else {
        VarAccess variableAccess = new VarAccess(position, symbol);
        return new Assignment(position, variableAccess, expr);
      }
    }

    /**
     * Visit a parse tree assignment nosemi stmt and create an AST
     * {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */

    /**
     * Visit a parse tree call stmt and create an AST {@link Call}. Since
     * {@link Call} is both
     * {@link Expression} and {@link Statement}, we simply delegate this to
     * {@link ExprVisitor#visitCallExpr(CruxParser.CallExprContext)} that we will
     * implement later.
     *
     * @return an AST {@link Call}
     */

    @Override
    public Statement visitCallStmt(CruxParser.CallStmtContext ctx) {
      Call callExpression = (Call) exprVisitor.visitCallExpr(ctx.callExpr());
      Position position = makePosition(ctx);
      return new Call(position, callExpression.getCallee(), callExpression.getArguments());
    }

    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The
     * template code
     * shows partial implementations that visit the then block and else block
     * recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     *
     * @return an AST {@link IfElseBranch}
     */

    @Override
    public Statement visitIfStmt(CruxParser.IfStmtContext ctx) {
      Expression condition = exprVisitor.visit(ctx.expr0());
      StatementList thenBlock = lower(ctx.stmtBlock(0));

      List<Statement> statements = new ArrayList<>();
      StatementList elseBlock = new StatementList(new Position(-1), statements);

      if (ctx.stmtBlock().size() > 1) {
        elseBlock = lower(ctx.stmtBlock(1));
      }

      Position position = makePosition(ctx);
      return new IfElseBranch(position, condition, thenBlock, elseBlock);    }

    /**
     * Visit a parse tree for loop and create an AST {@link Loop}. You'll going to
     * use a similar
     * techniques as {@link #visitIfStmt(CruxParser.IfStmtContext)} to decompose
     * this construction.
     *
     * @return an AST {@link Loop}
     */

    @Override
    public Statement visitLoopStmt(CruxParser.LoopStmtContext ctx) {
      StatementList body = lower(ctx.stmtBlock());

      Position position = makePosition(ctx);
      return new Loop(position, body);
    }

    /**
     * Visit a parse tree return stmt and create an AST {@link Return}. Here we show
     * a simple
     * example of how to lower a simple parse tree construction.
     *
     * @return an AST {@link Return}
     */
    @Override
    public Statement visitReturnStmt(CruxParser.ReturnStmtContext ctx) {
      Expression returnValue = null;
      if (ctx.expr0() != null) {
        returnValue = exprVisitor.visit(ctx.expr0());
      }
      Position position = makePosition(ctx);
      return new Return(position, returnValue);
    }

    /**
     * Creates a Break node
     */
    @Override
    public Statement visitBreakStmt(CruxParser.BreakStmtContext ctx) {
      Position position = makePosition(ctx);
      return new Break(position);
    }

    /**
     * Creates a Continue node
     */
    @Override
    public Statement visitContinueStmt(CruxParser.ContinueStmtContext ctx) {
      Position position = makePosition(ctx);
      return new Continue(position);
    }
  }

  private final class ExprVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expr0 to OpExpr Node Parsing the expr should be exactly as described in
     * the grammar
     */
    @Override
    public Expression visitExpr0(CruxParser.Expr0Context ctx) {
      // expr1 case
      if(ctx.op0() == null){
        return ctx.expr1(0).accept(this);
      }
      // expr1 op expr1
      else{
        Expression lhs = ctx.expr1(0).accept(this);
        Expression rhs = ctx.expr1(1).accept(this);
        CruxParser.Op0Context op0 = ctx.op0();
        String op0String = op0.getText();
        if(op0String.equals(">=")){
          return new OpExpr(makePosition(ctx), Operation.GE, lhs, rhs);
        }
        else if(op0String.equals("<=")){
          return new OpExpr(makePosition(ctx), Operation.LE,lhs, rhs);
        }
        else if(op0String.equals("!=")){
          return new OpExpr(makePosition(ctx), Operation.NE, lhs, rhs);
        }
        else if(op0String.equals("==")){
          return new OpExpr(makePosition(ctx), Operation.EQ, lhs, rhs);
        }
        else if(op0String.equals(">")){
          return new OpExpr(makePosition(ctx), Operation.GT, lhs, rhs);
        }
        else if(op0String.equals("<")){
          return new OpExpr(makePosition(ctx), Operation.LT, lhs, rhs);
        }
        // Should never get here
        else{
          return null;
        }
      }
    }

    /**
     * Parse Expr1 to OpExpr Node Parsing the expr should be exactly as described in
     * the grammar
     */
    @Override
    public Expression visitExpr1(CruxParser.Expr1Context ctx) {
      // expr2 case
      if(ctx.op1() == null){
        return ctx.expr2().accept(exprVisitor);
      }
      // expr1 op1 expr2
      else{
        Expression lhs = ctx.expr1().accept(exprVisitor);
        Expression rhs = ctx.expr2().accept(exprVisitor);
        CruxParser.Op1Context op1 = ctx.op1();
        String op1String = op1.getText();
        if(op1String.equals("+")){
          return new OpExpr(makePosition(ctx), Operation.ADD, lhs, rhs);
        }
        else if(op1String.equals("-")){
          return new OpExpr(makePosition(ctx), Operation.SUB, lhs, rhs);

        }
        else if(op1String.equals("||")){
          return new OpExpr(makePosition(ctx), Operation.LOGIC_OR, lhs, rhs);
        }
        // Should never get here
        else{
          return null;
        }
      }
    }

    /**
     * Parse Expr2 to OpExpr Node Parsing the expr should be exactly as described in
     * the grammer
     */
    @Override
    public Expression visitExpr2(CruxParser.Expr2Context ctx) {
      // expr3 case
      if(ctx.op2() == null){
        return ctx.expr3().accept(exprVisitor);
      }
      // expr2 op2 expr3 case
      else{
        Expression lhs = ctx.expr2().accept(exprVisitor);
        Expression rhs = ctx.expr3().accept(exprVisitor);
        CruxParser.Op2Context op2 = ctx.op2();
        String op2String = op2.getText();
        if(op2String.equals("*")){
          return new OpExpr(makePosition(ctx), Operation.MULT, lhs, rhs);
        }
        else if(op2String.equals("/")){
          return new OpExpr(makePosition(ctx), Operation.DIV, lhs, rhs);
        }
        else if(op2String.equals("&&")){
          return new OpExpr(makePosition(ctx), Operation.LOGIC_AND, lhs, rhs);
        }
        // Should never get here
        else{
          return null;
        }
      }
    }

    /**
     * Parse Expr3 to OpExpr Node Parsing the expr should be exactly as described in
     * the grammer
     */
    @Override
    public Expression visitExpr3(CruxParser.Expr3Context ctx) {
      if(ctx.designator() != null){
        return ctx.designator().accept(exprVisitor);
      }
      else if(ctx.literal() != null){
        return ctx.literal().accept(exprVisitor);
      }
      else if(ctx.callExpr() != null){
        return ctx.callExpr().accept(exprVisitor);
      }
      else if(ctx.expr3() != null){
        Expression left = ctx.expr3().accept(exprVisitor);
        return new OpExpr(makePosition(ctx), Operation.LOGIC_NOT, left, null);
      }
      else if(ctx.expr0() != null){
        return ctx.expr0().accept(exprVisitor);
      }
      // Should never get here, only for bugcatching
      else{
        return null;
      }
    }

    /**
     * Create an Call Node
     */
    @Override
    public Expression visitCallExpr(CruxParser.CallExprContext ctx) {
      String functionName = ctx.Identifier().getText();
      List<Expression> arguments = new ArrayList<>();

      if (ctx.exprList() != null) {
        for (ParserRuleContext exprContext : ctx.exprList().expr0()) {
          Expression argExpression = visit(exprContext);
          arguments.add(argExpression);
        }
      }

      Symbol calleeSymbol = symTab.lookup(makePosition(ctx), functionName);

      if (calleeSymbol == null) {
        System.err.println("Error: Function '" + functionName + "' not defined.");
        return null;
      }

      Position position = makePosition(ctx);

      return new Call(position, calleeSymbol, arguments);
    }

    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account
     * for the case when
     * the designator was dereferenced
     */
    @Override
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
      Position position = makePosition(ctx);
      String identifier = ctx.Identifier().getText();
      Symbol symbol = symTab.lookup(position, identifier);

      if (symbol == null) {
        System.err.println("Error: Identifier '" + identifier + "' is not defined.");
        return null;
      }

      if (ctx.expr0() != null && ctx.expr0().size() > 0) {
        Expression index = visit(ctx.expr0(0));
        if (index == null) {
          System.err.println("Error: Invalid index expression for array access.");
          return null;
        }
        return new ArrayAccess(position, symbol, index);
      } else {
        return new VarAccess(position, symbol);
      }
    }
    /**
     * Create an Literal Node
     */
    @Override
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {
      Position position = makePosition(ctx);

      if (ctx.Integer() != null) {
        long intValue = Long.parseLong(ctx.Integer().getText());
        return new LiteralInt(position, intValue);
      } else if (ctx.True() != null) {
        return new LiteralBool(position, true);
      } else if (ctx.False() != null) {
        return new LiteralBool(position, false);
      }

      return null;
    }
  }
}
